<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">

  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Breathing Metronome</title>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 20px 0;
      font-family: Arial, sans-serif;
      background-color: #000;
      color: #fff;
    }

    .controls {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .control-group {
      background-color: rgba(255, 255, 255, 0.1);
      padding: 15px;
      border-radius: 10px;
      margin-bottom: 15px;
      width: 300px;
    }

    .control-group h3 {
      margin: 0 0 15px 0;
      color: #1e90ff;
      font-weight: normal;
    }

    .control {
      margin-bottom: 10px;
    }

    .control label {
      display: inline-block;
      margin-bottom: 5px;
    }

    .control span {
      display: inline-block;
    }

    input[type="range"] {
      width: 200px;
      display: block;  /* Force the slider to be on its own line */
      margin-top: 5px;
    }

    button {
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      background-color: #1e90ff;
      border: none;
      border-radius: 5px;
      color: #fff;
      transition: background-color 0.3s;
      margin-bottom: 15px;
    }

    button:hover {
      background-color: #4682b4;
    }

    input:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .task-display {
      font-size: 24px;
      margin-bottom: 10px;
      text-align: center;
    }

    /* Game styles */
    .game-container {
      margin-top: 40px;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      background-color: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
    }

    .game-instruction {
      font-size: 20px;
      margin-bottom: 20px;
      color: #fff;
    }

    .game-timer {
      font-size: 16px;
      margin-top: 15px;
      color: #666;
      font-family: monospace;
    }

    .game-grid {
      display: grid;
      grid-template-columns: repeat(4, 80px);
      grid-template-rows: repeat(5, 80px);
      gap: 10px;
    }

    .game-rectangle {
      width: 80px;
      height: 80px;
      border-radius: 8px;
      cursor: pointer;
      transition: opacity 0.3s ease, transform 0.1s ease;
    }

    .game-rectangle:hover {
      transform: scale(0.95);
    }

    .game-rectangle.dissolving {
      animation: dissolve 2s ease-out forwards;
    }

    .game-rectangle.fading-in {
      animation: fadeIn 2s ease-in forwards;
    }

    @keyframes dissolve {
      0% {
        opacity: 1;
        transform: scale(1);
      }
      100% {
        opacity: 0;
        transform: scale(0.5);
      }
    }

    @keyframes fadeIn {
      0% {
        opacity: 0;
        transform: scale(0.5);
      }
      100% {
        opacity: 1;
        transform: scale(1);
      }
    }

    .game-rectangle.rainbow-row-0 {
      background-color: #ffb3ba !important; /* Pastel red */
    }

    .game-rectangle.rainbow-row-1 {
      background-color: #ffdfba !important; /* Pastel orange */
    }

    .game-rectangle.rainbow-row-2 {
      background-color: #ffffba !important; /* Pastel yellow */
    }

    .game-rectangle.rainbow-row-3 {
      background-color: #baffc9 !important; /* Pastel green */
    }

    .game-rectangle.rainbow-row-4 {
      background-color: #bae1ff !important; /* Pastel blue */
    }

    .color-blue {
      background-color: #007C92;
    }

    .color-green {
      background-color: #009B77;
    }

    .celebration {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 40px 60px;
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
      text-align: center;
      z-index: 1000;
      animation: celebration-bounce 0.6s ease-out;
    }

    @keyframes celebration-bounce {
      0% {
        transform: translate(-50%, -50%) scale(0.3);
        opacity: 0;
      }
      50% {
        transform: translate(-50%, -50%) scale(1.05);
      }
      100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
      }
    }

    .celebration h2 {
      font-size: 48px;
      margin: 0 0 20px 0;
      color: #fff;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
    }

    .celebration p {
      font-size: 24px;
      margin: 0 0 30px 0;
      color: #fff;
    }

    .celebration button {
      font-size: 20px;
      padding: 15px 40px;
      background-color: #fff;
      color: #667eea;
      font-weight: bold;
    }

    .celebration button:hover {
      background-color: #f0f0f0;
      transform: scale(1.05);
    }

    .confetti {
      position: fixed;
      width: 10px;
      height: 10px;
      background-color: #f0f;
      position: absolute;
      animation: confetti-fall 3s linear forwards;
    }

    @keyframes confetti-fall {
      0% {
        transform: translateY(0) rotate(0deg);
        opacity: 1;
      }
      100% {
        transform: translateY(100vh) rotate(720deg);
        opacity: 0;
      }
    }
  </style>
</head>
<body>
  <div class="controls">
    <div class="control-group">
      <button id="startButton">Start Noise</button>
      
      <!-- Mode toggle -->
      <div class="control">
        <label for="modeToggle">Separate Inhale/Exhale? </label>
        <input type="checkbox" id="modeToggle">
      </div>
      
      <!-- Inhale duration control (always visible) -->
      <div class="control" id="inhaleControl">
        <label for="inhaleSlider">Inhale Duration:</label>
        <span id="inhaleValue">6</span>s
        <input type="range" id="inhaleSlider" min="1" max="30" step="1" value="6">
      </div>

      <!-- Exhale duration control (always visible, disabled when checkbox unchecked) -->
      <div class="control" id="exhaleControl">
        <label for="exhaleSlider">Exhale Duration:</label>
        <span id="exhaleValue">6</span>s
        <input type="range" id="exhaleSlider" min="1" max="30" step="1" value="6">
      </div>
      
      <div class="control">
        <label for="brightnessSlider">Noise Brightness:</label>
        <span id="brightnessValue">100</span>%
        <input type="range" id="brightnessSlider" min="25" max="200" step="5" value="100">
      </div>
      <div class="control">
        <label for="volumeSlider">Volume:</label>
        <span id="volumeValue">50</span>
        <input type="range" id="volumeSlider" min="0" max="100" step="1" value="100">
      </div>
      <div class="control">
        <label for="boostSlider">Volume Boost:</label>
        <span id="boostValue">0</span>
        <input type="range" id="boostSlider" min="0" max="1000" step="1" value="0">
      </div>
      <div class="control">
        <label for="increaseSlider">Increase:</label>
        <span id="increaseValue">0</span>
        <input type="range" id="increaseSlider" min="-0.5" max="0.5" step="0.05" value="0">
      </div>
      <div class="control">
        <label for="minimumSlider">Minimum:</label>
        <span id="minimumValue">4</span>s
        <input type="range" id="minimumSlider" min="1" max="30" step="1" value="4">
      </div>
      <div class="control">
        <label for="maximumSlider">Maximum:</label>
        <span id="maximumValue">12</span>s
        <input type="range" id="maximumSlider" min="1" max="30" step="1" value="12">
      </div>

      <!-- Timer toggle -->
      <div class="control">
        <label for="timerToggle">Enable Time Limit? </label>
        <input type="checkbox" id="timerToggle">
      </div>

      <div class="control">
        <label for="minutesSlider">Minutes:</label>
        <span id="minutesValue">60</span>min
        <input type="range" id="minutesSlider" min="1" max="60" step="1" value="60">
      </div>
    </div>
  </div>

  <!-- Color Clicking Game -->
  <div class="game-container">
    <div class="game-instruction" id="gameInstruction">Tap the red</div>
    <div class="game-grid" id="gameGrid"></div>
    <div class="game-timer" id="gameTimer"></div>
  </div>

  <script>
    const startButton = document.getElementById('startButton');
    const brightnessSlider = document.getElementById('brightnessSlider');
    const brightnessValue = document.getElementById('brightnessValue');
    const volumeSlider = document.getElementById('volumeSlider');
    const volumeValue = document.getElementById('volumeValue');
    const boostSlider = document.getElementById('boostSlider');
    const boostValue = document.getElementById('boostValue');
    const minutesSlider = document.getElementById('minutesSlider');
    const minutesValue = document.getElementById('minutesValue');
    const increaseSlider = document.getElementById('increaseSlider');
    const increaseValue = document.getElementById('increaseValue');
    const maximumSlider = document.getElementById('maximumSlider');
    const maximumValue = document.getElementById('maximumValue');
    const minimumSlider = document.getElementById('minimumSlider');
    const minimumValue = document.getElementById('minimumValue');
    const modeToggle = document.getElementById('modeToggle');
    const timerToggle = document.getElementById('timerToggle');
    const inhaleSlider = document.getElementById('inhaleSlider');
    const inhaleValue = document.getElementById('inhaleValue');
    const exhaleSlider = document.getElementById('exhaleSlider');
    const exhaleValue = document.getElementById('exhaleValue');
    const inhaleControl = document.getElementById('inhaleControl');
    const exhaleControl = document.getElementById('exhaleControl');

    document.addEventListener('DOMContentLoaded', () => {
      // Reset slider values to their defaults on page load
      modeToggle.checked = false;
      exhaleSlider.disabled = true;

      timerToggle.checked = false;
      minutesSlider.disabled = true;

      brightnessSlider.value = 100;
      brightnessValue.textContent = brightnessSlider.value;

      volumeSlider.value = 50;
      volumeValue.textContent = volumeSlider.value;

      boostSlider.value = 0;
      boostValue.textContent = boostSlider.value;

      minutesSlider.value = 60;
      minutesValue.textContent = minutesSlider.value;

      increaseSlider.value = 0;
      increaseValue.textContent = increaseSlider.value;

      maximumSlider.value = 15;
      maximumValue.textContent = maximumSlider.value;

      minimumSlider.value = 4;
      minimumValue.textContent = minimumSlider.value;

      inhaleSlider.value = 6;
      inhaleValue.textContent = inhaleSlider.value;
      exhaleSlider.value = 6;
      exhaleValue.textContent = exhaleSlider.value;
    });

    brightnessSlider.addEventListener('input', () => {
      brightnessValue.textContent = brightnessSlider.value;
    });

    volumeSlider.addEventListener('input', () => {
      volumeValue.textContent = volumeSlider.value;
    });

    boostSlider.addEventListener('input', () => {
      boostValue.textContent = boostSlider.value;
    });

    minutesSlider.addEventListener('input', () => {
      minutesValue.textContent = minutesSlider.value;
    });

    increaseSlider.addEventListener('input', () => {
      increaseValue.textContent = parseFloat(increaseSlider.value).toFixed(2);
    });

    minimumSlider.addEventListener('input', () => {
      minimumValue.textContent = minimumSlider.value;
      if (parseInt(maximumSlider.value) < parseInt(minimumSlider.value)) {
        maximumSlider.value = minimumSlider.value;
        maximumValue.textContent = maximumSlider.value;
      }
    });

    maximumSlider.addEventListener('input', () => {
      maximumValue.textContent = maximumSlider.value;
      if (parseInt(maximumSlider.value) < parseInt(minimumSlider.value)) {
        minimumSlider.value = maximumSlider.value;
        minimumValue.textContent = minimumSlider.value;
      }
    });

    // Mode toggle event handler
    modeToggle.addEventListener('change', () => {
      if (modeToggle.checked) {
        // Enable separate inhale/exhale controls
        exhaleSlider.disabled = false;
      } else {
        // Disable exhale slider and sync it with inhale
        exhaleSlider.disabled = true;
        exhaleSlider.value = inhaleSlider.value;
        exhaleValue.textContent = exhaleSlider.value;
      }
    });

    // Timer toggle event handler
    timerToggle.addEventListener('change', () => {
      if (timerToggle.checked) {
        // Enable minutes slider
        minutesSlider.disabled = false;
      } else {
        // Disable minutes slider
        minutesSlider.disabled = true;
      }
    });

    // Inhale slider event handler
    inhaleSlider.addEventListener('input', () => {
      inhaleValue.textContent = inhaleSlider.value;
      // If checkbox is unchecked, sync exhale slider with inhale
      if (!modeToggle.checked) {
        exhaleSlider.value = inhaleSlider.value;
        exhaleValue.textContent = exhaleSlider.value;
      }
    });

    // Exhale slider event handler
    exhaleSlider.addEventListener('input', () => {
      exhaleValue.textContent = exhaleSlider.value;
    });

    // Note: This function is self-contained: it does not use any global variables.
    function createBrownNoise(audioContext, durationInSeconds, isHighPitch = false, brightnessMultiplier = 1.0) {
      const bufferSize = durationInSeconds * audioContext.sampleRate;
      const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const output = noiseBuffer.getChannelData(0);

      let lastOut = 0;
      for (let i = 0; i < bufferSize; i++) {
        const white = Math.random() * 2 - 1;

        // Adjust filter coefficient based on brightness
        // brightnessMultiplier: 0.25 (very dark/brown) to 2.0 (very bright/white)
        // At 1.0 (100%), use the original coefficients
        let filterCoeff;

        if (isHighPitch) {
          // Base coefficient for high pitch: 0.10 (already brighter)
          // Scale between 0.01 (darker) and 0.30 (brighter)
          filterCoeff = 0.10 * brightnessMultiplier;
          filterCoeff = Math.max(0.01, Math.min(0.30, filterCoeff));

          output[i] = (lastOut + (filterCoeff * white)) / (1.0 + filterCoeff);
          lastOut = output[i];
        } else {
          // Base coefficient for low pitch: 0.02 (already darker)
          // Scale between 0.005 (very dark/brown) and 0.15 (brighter/pink)
          filterCoeff = 0.06 * brightnessMultiplier;
          filterCoeff = Math.max(0.005, Math.min(0.15, filterCoeff));

          output[i] = (lastOut + (filterCoeff * white)) / (1.0 + filterCoeff);
          lastOut = output[i];
        }
      }

      // Normalize the output to consistent RMS level
      // Calculate RMS (Root Mean Square) of the signal
      let sumSquares = 0;
      for (let i = 0; i < bufferSize; i++) {
        sumSquares += output[i] * output[i];
      }
      const rms = Math.sqrt(sumSquares / bufferSize);

      // Target RMS level based on pitch mode
      const targetRMS = .1; //isHighPitch ? 0.05 : 0.15;

      // Normalize to target RMS
      const normalizationFactor = rms > 0 ? targetRMS / rms : 1.0;
      for (let i = 0; i < bufferSize; i++) {
        output[i] *= normalizationFactor;
      }

      const noiseSource = audioContext.createBufferSource();
      noiseSource.buffer = noiseBuffer;
      noiseSource.loop = false;
      return noiseSource;
    }

    // Note: This function is self-contained: it does not use any global variables.
    function planToPlayNoise(audioContext, startTime, duration, maxVolume, isHighPitch = false, brightnessMultiplier = 1.0) {
      let noiseSource = createBrownNoise(audioContext, duration, isHighPitch, brightnessMultiplier);
      let gainNode = audioContext.createGain();

      gainNode.gain.setValueAtTime(0, startTime);

      // Calculate proportional timing for smooth envelopes at any duration
      const fadeInTime1 = Math.min(0.5, duration * 0.1);
      const fadeInTime2 = Math.min(1.5, duration * 0.25);
      const sustainEnd = Math.max(fadeInTime2, duration * 0.65);
      const fadeOutStart = Math.max(sustainEnd + 0.1, duration - Math.min(0.8, duration * 0.15));

      gainNode.gain.linearRampToValueAtTime(maxVolume * 0.4, startTime + fadeInTime1);
      gainNode.gain.linearRampToValueAtTime(maxVolume * 1.0, startTime + fadeInTime2);
      gainNode.gain.linearRampToValueAtTime(maxVolume * 0.2, startTime + sustainEnd);
      gainNode.gain.linearRampToValueAtTime(maxVolume * 0.06, startTime + fadeOutStart);
      gainNode.gain.linearRampToValueAtTime(0, startTime + duration);

      noiseSource.connect(gainNode).connect(audioContext.destination);
      noiseSource.start(startTime);
      return noiseSource;
    }

    let startTime = null;
    let startTimeForAudioContext = null;
    let cycleCount = 0;
    let latestScheduledNoiseStartTime = null;
    let latestScheduledNoiseDuration = null;

    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    let noiseSource;
    let intervalId;
    let buttonIntervalId;

    function startNoiseSequence() {
      // Get UI values.
      const brightness = parseFloat(brightnessSlider.value) / 100;
      const volume = parseFloat(volumeSlider.value) / 100;
      const boost = parseFloat(boostSlider.value) / 100;
      const maxVolume = volume + boost;
      const totalMinutes = parseInt(minutesSlider.value);
      const increase = parseFloat(increaseSlider.value);
      const maximumDuration = parseFloat(maximumSlider.value);
      const minimumDuration = parseFloat(minimumSlider.value);
      const inhaleDuration = parseFloat(inhaleSlider.value);
      const exhaleDuration = parseFloat(exhaleSlider.value);

      // Set/update global variables.
      const isFirstTime = startTime === null;
      if (isFirstTime) {
        startTime = Date.now();
        startTimeForAudioContext = audioContext.currentTime;
        cycleCount = 0;
        latestScheduledNoiseStartTime = null;
      } else {
        cycleCount++;
      }

      // Check if we've exceeded the total time (only if timer is enabled).
      if (timerToggle.checked) {
        const elapsedMinutes = (Date.now() - startTime) / (1000 * 60);
        if (elapsedMinutes >= totalMinutes) {
          toggleNoise();
          return;
        }
      }

      // Calculate next duration.
      const isInhalePhase = cycleCount % 2 == 0;
      const nextDuration = Math.min(
        maximumDuration,
        Math.max(
          minimumDuration,
          (isInhalePhase ? inhaleDuration : exhaleDuration) + (increase * cycleCount)
        )
      );

      // Create a function to update the button text.
      const updateButtonText = () => {
        const phase = isInhalePhase ? "Inhale" : "Exhale";
        startButton.textContent = `Stop Noise (${phase} ${latestScheduledNoiseDuration.toFixed(1)}s)`;
      }
      
      // Schedule the next noise.
      if (isFirstTime) {
        latestScheduledNoiseStartTime = audioContext.currentTime;
        latestScheduledNoiseDuration = nextDuration;
      } else {
        latestScheduledNoiseStartTime = latestScheduledNoiseStartTime + latestScheduledNoiseDuration;
        latestScheduledNoiseDuration = nextDuration;
      }
      
      // Use different pitch only when separate inhale/exhale mode is enabled
      const useDifferentPitch = modeToggle.checked;
      const isHighPitch = useDifferentPitch && isInhalePhase;
      noiceSource = planToPlayNoise(audioContext, latestScheduledNoiseStartTime, latestScheduledNoiseDuration, maxVolume, isHighPitch, brightness);

      // Schedule to update the button text.
      intervalId = setTimeout(
        updateButtonText,
        (latestScheduledNoiseStartTime - audioContext.currentTime) * 1000
      );

      // Schedule to start the next noise.
      buttonIntervalId = setTimeout(
        startNoiseSequence,
        (latestScheduledNoiseStartTime + nextDuration - 0.5 - audioContext.currentTime) * 1000
      );
    }

    function toggleNoise() {
      if (startTime !== null) {
        if (noiseSource) {
          noiseSource.stop();
          noiseSource.disconnect();
        }
        clearTimeout(intervalId);
        clearTimeout(buttonIntervalId);
        startButton.textContent = "Start Noise";
        startTime = null;
      } else {
        startNoiseSequence();
      }
    }

    startButton.addEventListener('click', toggleNoise);

    // Color Clicking Game Logic
    const gameGrid = document.getElementById('gameGrid');
    const gameInstruction = document.getElementById('gameInstruction');
    const gameTimer = document.getElementById('gameTimer');
    const COLORS = ['blue', 'green'];
    const GRID_WIDTH = 4;
    const GRID_HEIGHT = 5;
    const TOTAL_RECTANGLES = GRID_WIDTH * GRID_HEIGHT;
    const GAME_TIMER_DURATION = 3 * 60 * 1000; // 3 minutes in milliseconds

    // EASY TOGGLE: Set to false to hide the timer
    const SHOW_TIMER = false;

    let targetColor = COLORS[Math.floor(Math.random() * COLORS.length)];
    let rectangles = [];
    let gameStartTime = null;
    let isPostTimer = false;
    let timerInterval = null;

    function initializeGrid() {
      gameGrid.innerHTML = '';
      rectangles = [];

      // Create random colors ensuring at least one of each color
      let colors = [];

      // Add at least one of each color
      colors.push('blue');
      colors.push('green');

      // Fill the rest randomly
      for (let i = 2; i < TOTAL_RECTANGLES; i++) {
        colors.push(COLORS[Math.floor(Math.random() * COLORS.length)]);
      }

      // Shuffle the colors array
      for (let i = colors.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [colors[i], colors[j]] = [colors[j], colors[i]];
      }

      // Create rectangles
      for (let i = 0; i < TOTAL_RECTANGLES; i++) {
        const rect = document.createElement('div');
        rect.className = `game-rectangle color-${colors[i]}`;
        rect.dataset.color = colors[i];
        rect.addEventListener('click', handleRectangleClick);
        gameGrid.appendChild(rect);
        rectangles.push(rect);
      }

      updateInstruction();
    }

    function updateInstruction() {
      const colorSpan = `<span style="color: ${targetColor === 'blue' ? '#5E9DD9' : '#40E0D0'}">${targetColor}</span>`;
      gameInstruction.innerHTML = `Tap the ${colorSpan}`;
    }

    function updateTimer() {
      if (!SHOW_TIMER) {
        gameTimer.style.display = 'none';
        return;
      }

      if (gameStartTime === null) {
        gameTimer.textContent = '';
        return;
      }

      const elapsedTime = Date.now() - gameStartTime;
      const elapsedSeconds = Math.floor(elapsedTime / 1000);
      const minutes = Math.floor(elapsedSeconds / 60);
      const seconds = elapsedSeconds % 60;

      const formattedTime = `${minutes}:${seconds.toString().padStart(2, '0')}`;

      if (elapsedTime >= GAME_TIMER_DURATION) {
        gameTimer.textContent = `Time: ${formattedTime} (overtime mode)`;
      } else {
        gameTimer.textContent = `Time: ${formattedTime}`;
      }
    }

    function startTimer() {
      if (timerInterval) return; // Already running

      timerInterval = setInterval(updateTimer, 100);
      updateTimer(); // Update immediately
    }

    function stopTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
    }

    function handleRectangleClick(event) {
      const clickedRect = event.target;
      const clickedColor = clickedRect.dataset.color;

      if (clickedColor === targetColor) {
        // Start timer on first correct click
        if (gameStartTime === null) {
          gameStartTime = Date.now();
          startTimer();
        }

        // Check if 3 minutes have passed
        const elapsedTime = Date.now() - gameStartTime;
        if (elapsedTime >= GAME_TIMER_DURATION) {
          isPostTimer = true;
        }

        // Correct color clicked - dissolve
        clickedRect.classList.add('dissolving');

        setTimeout(() => {
          if (isPostTimer) {
            // Post-timer: remove rectangle permanently (keep in grid but invisible)
            clickedRect.style.opacity = '0';
            clickedRect.style.pointerEvents = 'none';
            clickedRect.dataset.dissolved = 'true';

            // Check if all target colors are dissolved
            checkPostTimerGameState();
          } else {
            // Pre-timer: replace with new random color
            const newColor = COLORS[Math.floor(Math.random() * COLORS.length)];
            clickedRect.dataset.color = newColor;
            clickedRect.className = `game-rectangle color-${newColor}`;

            // Add fade-in animation
            clickedRect.classList.add('fading-in');

            // Remove the fading-in class after animation completes
            setTimeout(() => {
              clickedRect.classList.remove('fading-in');
            }, 2000);

            // Check if game is over (no more target colors)
            checkGameOver();
          }
        }, 2000);
      }
      // If incorrect color, do nothing
    }

    function checkPostTimerGameState() {
      // Check how many rectangles are still visible and what colors remain
      const visibleRectangles = rectangles.filter(rect => rect.dataset.dissolved !== 'true');
      const hasTargetColor = visibleRectangles.some(rect => rect.dataset.color === targetColor);

      if (!hasTargetColor && visibleRectangles.length > 0) {
        // All target colors dissolved, switch to the other color
        targetColor = targetColor === 'blue' ? 'green' : 'blue';
        updateInstruction();
      } else if (visibleRectangles.length === 0) {
        // All rectangles dissolved - game complete!
        showCelebration();
      }
    }

    function checkGameOver() {
      const hasTargetColor = rectangles.some(rect => rect.dataset.color === targetColor);

      if (!hasTargetColor) {
        // Player wins! Show rainbow rows
        rectangles.forEach((rect, index) => {
          const row = Math.floor(index / GRID_WIDTH);
          rect.classList.add(`rainbow-row-${row}`);
        });

        // After celebration, switch to opposite color and reset grid
        targetColor = targetColor === 'blue' ? 'green' : 'blue';
        setTimeout(() => {
          initializeGrid();
        }, 2000);
      }
    }

    function showCelebration() {
      // Hide instruction
      gameInstruction.style.display = 'none';

      // Create celebration element
      const celebration = document.createElement('div');
      celebration.className = 'celebration';
      celebration.innerHTML = `
        <h2>ðŸŽ‰ Congratulations! ðŸŽ‰</h2>
        <p>You completed the game!</p>
        <button id="playAgainBtn">Woohoo</button>
      `;
      document.body.appendChild(celebration);

      // Create confetti
      createConfetti();

      // Add play again button listener
      document.getElementById('playAgainBtn').addEventListener('click', () => {
        celebration.remove();
        resetGame();
      });
    }

    function createConfetti() {
      const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ffa500', '#ff1493'];

      for (let i = 0; i < 50; i++) {
        setTimeout(() => {
          const confetti = document.createElement('div');
          confetti.className = 'confetti';
          confetti.style.left = Math.random() * 100 + 'vw';
          confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
          confetti.style.animationDelay = Math.random() * 0.5 + 's';
          confetti.style.animationDuration = (2 + Math.random() * 2) + 's';
          document.body.appendChild(confetti);

          setTimeout(() => confetti.remove(), 5000);
        }, i * 30);
      }
    }

    function resetGame() {
      // Stop and reset timer
      stopTimer();
      gameStartTime = null;
      isPostTimer = false;

      // Reset game state
      targetColor = COLORS[Math.floor(Math.random() * COLORS.length)];
      gameInstruction.style.display = 'block';

      // Clear timer display
      updateTimer();

      // Reinitialize grid
      initializeGrid();
    }

    // Initialize the game when page loads
    document.addEventListener('DOMContentLoaded', () => {
      initializeGrid();
    });

  </script>
</body>
</html>
